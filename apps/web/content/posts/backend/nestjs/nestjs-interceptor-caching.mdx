---
title: "Custom Interceptor 기반 캐싱을 통해 조회 성능 높히기"
description: "NestJS Interceptor를 활용한 Redis 캐싱 전략으로 API 응답 속도를 70배 향상시키는 방법"
date: 2025-03-20
categories: ["nestjs"]
tags: ["NestJS", "TypeScript", "Cache", "Redis", "Interceptor"]
author: "Carefreelife98"
thumbnail: "/images/backend/nestjs/nestjs-interceptor-caching1.png"
published: true
---

# Interceptor 란?

대량의 계층형 데이터를 반환하는 API의 응답 속도를 높히기 위해 Nest.js 에서 제공하는 Interceptor 를 사용하여 더욱 편리하게 API Endpoint 별 Redis 캐싱을 수행하도록 한다.

![path](/images/backend/nestjs/nestjs-interceptor-caching1.png)

- `Interceptor` 는 `NestInterceptor` 인터페이스를 구현하며 `@Injectable()` 데코레이터가 적용된 `NestJS` 의 클래스이다.
- `AOP (Aspect Oriented Programming)` 기술로부터 영감을 얻은 아래와 같은 기능들을 가지고 있다.
  - **Method 실행 전/후 간의 부가 로직 수행 기능 제공 (전/후처리)**
  - **함수(function) 수행 결과 및 Exception 반환 형태의 변환 (Transform)**
  - **기본 함수의 동작 확장**
  - **특정한 목적을 위해 함수를 완벽히 Override (대체) 가능 (캐싱 등)**
    - **캐싱**: 요청이 들어왔을 때, 인터셉터가 캐시된 결과가 존재하는지 먼저 확인. 만약 캐시된 결과가 있다면, 실제 비즈니스 로직을 실행하지 않고 캐시된 데이터를 바로 반환.

## Interceptor 기초

모든 Interceptor 들은 아래와 같은 두 개의 인자를 가지는 intercept() 메서드를 구현해야 한다.

### 1. ExecutionContext

`ArgumentsHost` 를 상속받음. (적절한 인자를 사용하기 위한 HTTP / RPC / WebSockets 의 구분을 제공.)

- 공식 문서: [ArgumentsHost](https://docs.nestjs.com/fundamentals/execution-context#argumentshost-class)
- 공식 문서: [ExecutionContext](https://docs.nestjs.com/fundamentals/execution-context)

### 2. CallHandler

인터셉터가 특정 시점에 RouteHandler 를 불러오도록 사용할 수 있는 `handle()` 메서드를 구현.

- `handle()` 메서드가 `Observable` 을 반환하기 때문에 `RxJS` 의 강력한 연산자를 통해 이후 응답을 처리할 수 있다.

## Interceptor 전처리 / 후처리 예시

```typescript
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class CarefreeInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    console.log('Before...'); // 요청에 대한 전처리

    const now = Date.now();
    return next
      .handle()
      .pipe(
        tap(() => console.log(`After... ${Date.now() - now}ms`)),
      );
  }
}
```

```typescript
@Controller('/build')
@UseInterceptors(CarefreeInterceptor)
export class CarefreeLife {
  @Post()
  build() {
    console.log('Build CarefreeLife!');
  }
}
```

수행 결과:
```bash
Before...
Build CarefreeLife!
After... 1ms
```

# 캐싱 로직이 필요했던 이유

- `변동성이 적은 대규모 계층형 트리 데이터` 를 주로 조회해오는 서비스를 개발하는 과정에서 매 조회 시마다 DB 쿼리를 수행하는 것은 `리소스 낭비` 라는 판단을 내렸다.
- 쿼리 뿐만 아니라, 전체 데이터를 Closure Table 기반으로 구현된 계층형 트리 리스트로 가공하는 과정에서 다양한 부가 정보들이 삽입되는데, 해당 가공 로직 또한 매 조회 시 마다 수행하는 것은 불필요하다는 판단을 내렸다.
- 따라서 해당 데이터를 각 API Endpoint 및 쿼리 파라미터의 조합을 기준으로 `Redis 에 캐싱하여 조회 성능을 극대화` 하는 방향으로 결정했다.

# 왜 Custom Interceptor 를 구현하여 캐싱을 수행했는가?

- Interceptor 를 사용하는 경우, `Request stream 을 통해 컨트롤러에 전달되기 전에 전처리를 수행` 할 수 있어 내부 로직 진입 전에 캐시 여부를 확인하여 즉시 반환 할 수 있기 때문에 현 상황에서 가장 효율적이라는 판단을 내렸다.
- 캐시가 존재하지 않는다면, Interceptor 를 통해 반환된 `Observable 을 사용해 후처리를 수행하여, Database 및 서비스를 거쳐 가공된 Response 를 캐싱` 하는것에도 가장 이상적인 방향이라고 생각했다.
- 또한 캐싱 로직을 특정 서비스만을 위한 내부 로직으로 구현하지 않고 `Custom Interceptor 기반의 공통 유틸` 로서 구현해놓는다면, 해당 프로젝트의 모든 서비스에서 편리하게 API 별 캐싱을 수행할 수 있게 되어 `확장 가능한 범용 소스` 가 될 수 있기 때문이었다.

# RedisInterceptor 구현

```typescript
import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import { catchError, Observable, of } from 'rxjs';
import { RedisCacheService } from '../cache/redis.cache.service';
import { tap } from 'rxjs/operators';
import { instanceToPlain } from 'class-transformer';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class RedisInterceptor implements NestInterceptor {
    constructor(
        private readonly redisService: RedisCacheService,
        private readonly configService: ConfigService,
    ) {}
    private readonly logger = new Logger('RedisInterceptor');

    async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
        const prefix = this.configService.get<string>('REDIS_INTERCEPTOR_CACHE_PREFIX');
        const ttl = this.configService.get<number>('REDIS_INTERCEPTOR_CACHE_TTL');
        const key = RedisInterceptor.generateCacheKeyByHostType(context, prefix);

        const cachedResponse = await this.redisService.get(key);
        if (cachedResponse) {
            return of(cachedResponse);
        }

        return next.handle().pipe(
            tap(async (response) => {
                const safeResponse = instanceToPlain(response);
                await this.redisService.set(key, JSON.stringify(safeResponse), ttl);
            }),
            catchError((error) => {
                this.logger.error(`Error ::: RedisInterceptor ::: message [${error.message}]`, { stack: error.stack });
                throw Error(error);
            }),
        );
    }

    static generateCacheKeyByHostType(ctx: ExecutionContext, prefix: string): string {
        const hostType = ctx.getType();

        if (hostType === 'http') {
            const request = ctx.switchToHttp().getRequest<Request>();
            prefix += encodeURIComponent(request.url);
        }

        return prefix;
    }
}
```

## intercept() 메서드 설명

```typescript
async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
  // 전처리 과정 - 캐시가 존재하는 경우 캐시데이터 반환
  const prefix = this.configService.get<string>('REDIS_INTERCEPTOR_CACHE_PREFIX');
  const ttl = this.configService.get<number>('REDIS_INTERCEPTOR_CACHE_TTL');
  const key = RedisInterceptor.generateCacheKeyByHostType(context, prefix);

  const cachedResponse = await this.redisService.get(key);
  if (cachedResponse) {
    return of(cachedResponse);
  }

  // 후처리 과정 - 캐시가 존재하지 않는 경우 response 데이터를 Redis 에 캐싱
  return next.handle().pipe(
    tap(async (response) => {
      const safeResponse = instanceToPlain(response);
      await this.redisService.set(key, JSON.stringify(safeResponse), ttl);
    }),
    catchError((error) => {
      this.logger.error(`Error ::: RedisInterceptor ::: message [${error.message}]`, { stack: error.stack });
      throw Error(error);
    }),
  );
}
```

# Custom Interceptor 사용 예시 및 결과

## 사용 예시

```typescript
import { Controller, UseInterceptors, BadRequestException } from '@nestjs/common';
import { RedisInterceptor } from '../../common/interceptor/redis.interceptor';
import { CarefreeService } from './carefree.service';

@UseInterceptors(RedisInterceptor)
@Controller('care')
export class CarefreeController {
  constructor(private readonly carefreeService: CarefreeService) {}

  @Get('free')
  public async find(@Query('free') free: string): Promise<FreeDto> {
    if (!free) throw new BadRequestException({}, 'carefree 가 확인되지 않았습니다.');

    const response = await this.carefreeService.findFree(free);
    return FreeDto.of({ data: response });
  }

  @Get('life')
  public async findLife(@Query('life') life: string): Promise<LifeDto> {
    if (!life) throw new BadRequestException({}, 'life 가 확인되지 않았습니다.');

    const response = await this.carefreeService.generateLife(life);
    return LifeDto.of({ data: response });
  }
}
```

## 결과

![path](/images/backend/nestjs/nestjs-interceptor-caching2.png)

- Winston 기반 로깅 Interceptor 를 통해 각 API 호출 별 실행 시간 또한 로깅하고 있다.
- `209ms` 정도 소요되던 API Response time 이 `3ms` 정도로 **약 70배** 감소된 것을 확인 할 수 있다.
